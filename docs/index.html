<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">Home | collisions</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Separating Axis Theorem (SAT) Polygon, Circle, Line, and Point Collision Detection"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="collisions"><meta property="twitter:description" content="Separating Axis Theorem (SAT) Polygon, Circle, Line, and Point Collision Detection"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Sinova/Collisions"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Collisions.js~Collisions.html">Collisions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#modules">modules</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/modules/Body.js~Body.html">Body</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/modules/Circle.js~Circle.html">Circle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/modules/Polygon.js~Polygon.html">Polygon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/modules/Result.js~Result.html">Result</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="collisions">Collisions</h1><p><strong>Collisions</strong> is a JavaScript library used to quickly and accurately detect collisions between Polygons, Circles, Lines, and Points. It combines the efficiency of a <a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding Volume Hierarchy</a> (BVH) for broad-phase searching with the accuracy of the <a href="https://en.wikipedia.org/wiki/Separating_axis_theorem">Separating Axis Theorem</a> (SAT) for narrow-phase collision testing.</p>
<h1 id="installation">Installation</h1><pre><code class="lang-bash"><code class="source-code prettyprint">npm install collisions</code>
</code></pre>
<h1 id="documentation">Documentation</h1><p><a href="https://sinova.github.com/Collisions/docs/">Click here</a> to view the documentation (this README is also there).</p>
<h1 id="demos">Demos</h1><ul>
<li><a href="https://sinova.github.com/Collisions/demo">Movement</a></li>
<li><a href="https://sinova.github.com/Collisions/demo?stress">Stress Test</a></li>
</ul>
<h1 id="usage">Usage</h1><pre><code class="lang-JavaScript"><code class="source-code prettyprint">import Collisions from &apos;collisions&apos;;

// Create the collision system
const system = new Collisions();

// Create a Result object for collecting information about the collisions
const result = system.createResult();

// Add the player (represented by a Circle)
const player = system.createCircle(0, 0, 10);

// Create some walls (represented by Polygons)
const wall1 = system.createPolygon(10, 10, [[-20, -40], [-10, -70], [30, -40], [20, 30], [-30, 20]]);
const wall2 = system.createPolygon(10, 10, [[-20, -40], [-10, -70], [30, -40], [20, 30], [-30, 20]]);
const wall3 = system.createPolygon(10, 10, [[-20, -40], [-10, -70], [30, -40], [20, 30], [-30, 20]]);

// Get the potential collisions (this quickly rules out walls that have no chance of colliding with the player)
const potentials = player.potentials();

// Loop through the potential collisions
for(const wall of potentials) {
    // Test if the player collides with the wall
    if(player.collides(wall, result)) {
        // Push the player out of the wall
        player.x -= result.overlap * result.overlap_x;
        player.y -= result.overlap * result.overlap_y;
    }
}</code>
</code></pre>
<h1 id="getting-started">Getting Started</h1><p><strong>Collisions</strong> provides functions to perform both broad-phase and narrow-phase collision tests. In order to take full advantage of both phases, all bodies need to be tracked within a collision system.</p>
<p>To create a collision system, simply instantiate the Collisions class:</p>
<pre><code class="lang-JavaScript"><code class="source-code prettyprint">import Collisions from &apos;collisions&apos;;

const system = new Collisions();</code>
</code></pre>
<p>The resulting system exposes several functions for creating bodies:</p>
<pre><code class="lang-JavaScript"><code class="source-code prettyprint">const circle  = system.createCircle(100, 100, 10);
const polygon = system.createPolygon(50, 50, [[0, 0], [20, 20], [-10, 10]]);
const line    = system.createLine(-30, 5, [[-30, 0], [-20, -10], [-10, 0]]);
const point   = system.createPoint(10, 10);</code>
</code></pre>
<p>Those functions create their respective body and automatically insert it into the system. However, it&apos;s possible to create bodies separately and insert them into the system manually:</p>
<pre><code class="lang-JavaScript"><code class="source-code prettyprint">import {Collisions, Circle, Polygon, Line, Point} from &apos;collisions&apos;;

const system  = new Collisions();
const circle  = new Circle(100, 100, 10);
const polygon = new Polygon(50, 50, [[0, 0], [20, 20], [-10, 10]]);
const line    = new Line(-30, 5, [[-30, 0], [-20, -10], [-10, 0]]);
const point   = new Point(10, 10);

system.insert(circle, polygon, line, point);</code>
</code></pre>
<p>Bodies can be removed also:</p>
<pre><code class="lang-JavaScript"><code class="source-code prettyprint">system.remove(polygon, point);</code>
</code></pre>
<p>When the <strong>result</strong> parameter is supplied to a collision function, three of the properties set on the object are <strong>overlap</strong>, <strong>overlap_x</strong>, and <strong>overlap_y</strong>. Together, these values describe how much and in what direction a body is overlapping another body. More specifically, <strong>overlap_x</strong> and <strong>overlap_y</strong> make up the direction vector and <strong>overlap</strong> is the magnitude of that vector.</p>
<p>These values can be used to &quot;push&quot; one body out of another using the minimum distance required. Effectively, subtracting this vector from an body&apos;s position will cause the objects to no longer collide. Here&apos;s a simple example:</p>
<pre><code class="lang-JavaScript"><code class="source-code prettyprint">
const result = system.createResult();

if(player.collides(wall, result)) {
    player.x -= result.overlap * result.overlap_x;
    player.y -= result.overlap * result.overlap_y;
}</code>
</code></pre>
<h1 id="faq">FAQ</h1><h4 id="why-shouldn--39-t-i-just-use-a-physics-engine-">Why shouldn&apos;t I just use a physics engine?</h4><p>Projects requiring physics are enthusiastically recommended to use one of the many physics engines that are out there (e.g. <a href="https://github.com/liabru/matter-js">Matter.js</a> or <a href="https://github.com/shakiba/planck.js">Planck.js</a>). However, many projects use physics engines solely for collision detection, and developers often find themselves having to work around some of the assumptions that are made by these engines (gravity, velocity, friction, etc.). <strong>Collisions</strong> was written to fill this need.</p>
<h4 id="why-does-potentials---return-an-iterator-instead-of-an-array-">Why does potentials() return an Iterator instead of an Array?</h4><p>Populating an array with references to potential collisions can take up quite a bit of memory when done for thousands of bodies (even if each body has an array that it recycles). For instance, if the system has 1,000 bodies and each one is potentially colliding with five bodies on average, that&apos;s 5,000 references in total. Do this every frame and the garbage collector can start to get noticeably bogged down. Iterators solve this problem by only detecting and yielding a single potential collision at a time as you loop through them. Memory profiles showed the allocations per frame drop from 50 kilobytes to 10 bytes. The reduction in garbage collection far outweighs the small peformance cost of using Iterators.</p>
<h4 id="why-does-the-source-code-seem-to-have-a-lot-of-copy-paste-">Why does the source code seem to have a lot of copy/paste?</h4><p><strong>Collisions</strong> was written with performance as its primary focus. Conscious choices were made to sacrifice readability in order to avoid the overhead of unnecessary function calls or property lookups.</p>
<h1 id="limitations">Limitations</h1><p>SAT assumes all tested polygons are convex. Handling concave shapes requires breaking them down into their component convex polygons (Convex Decomposition) and testing them for collisions individually. There are plans to integrate this functionality into the library in the future, but for now, check out <a href="https://github.com/schteppe/poly-decomp.js">poly-decomp.js</a>.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
